## 时间复杂度的计算

计算一个算法的时间复杂度，不可能把所有的算法都编写出实际的程序出来让计算机跑，这样会做很多无用功，效率太低。实际采用的方法是估算算法的时间复杂度。

在学习C语言的时候讲过，程序由三种结构构成：顺序结构、分支结构和循环结构。顺序结构和分支结构中的每段代码只运行一次；循环结构中的代码的运行时间要看循环的次数。

由于是估算算法的时间复杂度，相比而言，循环结构对算法的执行时间影响更大。所以，**算法的时间复杂度，主要看算法中使用到的循环结构中代码循环的次数（称为“频度”）**。次数越少，算法的时间复杂度越低。

例如：
a) ++x; s=0;
b) for (int i=1; i<=n; i++) { ++x; s+=x; }
c) for (int i=1; i<=n; i++) { for (int j=1; i<=n; j++) { ++x; s+=x; } }

上边这个例子中，a 代码的运行了 1 次，b 代码的运行了 n 次，c 代码运行了 n*n 次。

## 时间复杂度的表示

算法的时间复杂度的表示方式为：

O(频度)

这种表示方式称为`大“O”记法`。

> 注意，是大写的字母`O`，不是数字`0`。

对于上边的例子而言，a 的时间复杂度为`O(1)`，b 的时间复杂度为`O(n)`，c 的时间复杂度为为O(n<sup>2</sup>)。

如果a、b、c组成一段程序，那么算法的时间复杂度为O(n<sup>2</sup>+n+1)。但这么表示是不对的，还需要对n<sup>2</sup>+n+1进行简化。

简化的过程总结为3步：

- 去掉运行时间中的所有加法常数。（例如 n<sup>2</sup>+n+1，直接变为 n<sup>2</sup>+n）
- 只保留最高项。（n<sup>2</sup>+n 变成 n<sup>2</sup>）
- 如果最高项存在但是系数不是1，去掉系数。（n<sup>2</sup> 系数为 1）


所以，最终a、b和c合并而成的代码的时间复杂度为O(n<sup>2</sup>)。

## 常用的时间复杂度的排序

列举了几种常见的算法时间复杂度的比较（又小到大）：

```
O(1)常数阶` < `O(logn)对数阶` < `O(n)线性阶` < `O(n2)平方阶` < `O(n3)(立方阶)` < `O(2n) (指数阶)
```

## 拿时间换空间，用空间换时间

算法的时间复杂度和空间复杂度是可以相互转化的。

谷歌浏览器相比于其他的浏览器，运行速度要快。是因为它占用了更多的内存空间，以空间换取了时间。

算法中，例如判断某个年份是否为闰年时，如果想以时间换取空间，算法思路就是：当给定一个年份时，判断该年份是否能被4或者400整除，如果可以，就是闰年。

如果想以空间换时间的话，判断闰年的思路就是：把所有的年份先判断出来，存储在数组中（年份和数组下标对应），如果是闰年，数组值是1，否则是0；当需要判断某年是否为闰年时，直接看对应的数组值是1还是0，不用计算就可以马上知道。

## 空间复杂度

其实我们在做算法分析时，往往会忽略空间复杂度，可能是因为现在计算机的空间已经越来越便宜了，成本很低，而一台计算机的 CPU 的性能始终很难得到太大的提升。但是空间复杂度作为另一个算法性能指标，也是我们需要掌握的，这能够让程序在时间和空间上都得到优化，成为一个好的算法。

空间复杂度的表示其实和时间复杂度是一样的，都用大 O 符号表示。空间复杂度是对一个算法在运行过程中所消耗的临时空间的一个度量。

空间复杂度的计算方式和时间复杂度一样，也不包括这个函数的低阶项和首项系数。

一般我们认为对于一个算法，本身的数据会消耗一定的空间，可能还需要一些其他空间，如果需要的其他空间是有限的，那么这个时间复杂度为 O(1)。相对地，也有 O(n)、O(nlogn)、O(n2)。

在学会了时间复杂度的相关内容之后，学习空间复杂度其实就没有什么难点了，对于更多的内容，我们会通过后面的算法慢慢地了解。

## 摘取文章

[时间复杂度和空间复杂度及其计算方法详解](http://data.biancheng.net/view/114.html)

[算法时间复杂度和空间复杂度的计算](http://data.biancheng.net/view/2.html)